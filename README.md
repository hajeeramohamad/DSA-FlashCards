[![](res/algodeck.jpg)](#algo-deck)

<a href="https://www.buymeacoffee.com/teivah" target="_blank"><img src="https://www.buymeacoffee.com/assets/img/custom_images/orange_img.png" alt="Buy Me A Coffee" style="height: 41px !important;width: 174px !important;box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;-webkit-box-shadow: 0px 3px 2px 0px rgba(190, 190, 190, 0.5) !important;" ></a>

## Overview

Algo Deck is an **open-source collection of +200 algorithmic flash cards**.

It helps you preparing and succeeding in your **algorithm & data structure interview**. The code examples are in Java.

The topics covered are the following:
- [Array](array.md): reversing an array, finding a pivot, handling a dynamic array, etc.  
- [Bit](bit.md): operators, bit manipulation, etc.
- [Complexity](complexity.md): algorithm & data structures complexity
- [Dynamic Programming](dynamicprogramming.md): dynamic programming concept
- [Encoding](encoding.md): encoding theory
- [General](general.md): general knowledge including how to approach a problem or testing a first solution
- [Graph](graph.md): A*, Dijkstra, BFS vs DFS, cycles detection, topological sort, etc.
- [Greedy](greedy.md): greedy algorithms concepts
- [Hash Table](hashtable.md): hashtable data structure
- [Heap](heap.md): heap data structure including min-heap/max heap, binary heap use cases, etc.
- [Linked List](linkedlist.md): linked list data structure, how to get the middle element, iterate over two lists, doubly linked list, etc.
- [Math](math.md): discrete math
- [Queue](queue.md): queue data structure
- [Recursion](recursion.md): recursion concepts
- [Sort](sort.md): sort algorithms including concepts, complexity, use cases, etc.
- [Stack](stack.md): stack data structure
- [String](string.md): string permutation, rotation, rabin-karp substring search, etc.
- [Technique](technique.md): most important techniques to master to solve algorithmic problems including greedy techniques, runner, sliding window, etc.
- [Tree](tree.md): binary tree use cases, binary search tree, 2-3 tree, red-black tree, use cases, etc. 

## Anki Deck

[Anki](https://apps.ankiweb.net/) is a free software (Windows/Mac/Linux/iPhone/Android) which makes remembering things easy. It utilizes spaced repetition which is a proven technique to increase the rate of memorization:  

[![](http://img.youtube.com/vi/-uMMRjrzPmE/0.jpg)](http://www.youtube.com/watch?v=-uMMRjrzPmE "Spaced Repetition: The most powerful study technique")

> The single biggest change that Anki brings about is that it means memory is no longer a haphazard event, to be left to chance. Rather, it guarantees I will remember something, with minimal effort. That is, Anki makes memory a choice.

Michael A. Nielsen, "Augmenting Long-term Memory"

Thus, using Anki is a great way to prepare your algorithm & data structure interview. 

The **Anki version** (an Anki clone of the cards available in this repo) is available for $14.99:

[![paypal](https://www.paypalobjects.com/en_US/i/btn/btn_buynowCC_LG.gif)](https://www.paypal.com/cgi-bin/webscr?cmd=_s-xclick&hosted_button_id=W4QQBV8VB4KZ8)

## Cards Index

### Array

* [Algorithm to reverse an array](array.md#algorithm-to-reverse-an-array)
* [Array complexity: access, search, insert, delete](array.md#array-complexity-access-search-insert-delete)
* [Binary search in a sorted array algorithm](array.md#binary-search-in-a-sorted-array-algorithm)
* [Find an element in a rotated sorted array](array.md#find-an-element-in-a-rotated-sorted-array)
* [Given an array, move all the 0 to the left while maintaining the order of the other elements](array.md#given-an-array-move-all-the-0-to-the-left-while-maintaining-the-order-of-the-other-elements)
* [How to detect if an element is a pivot in a rotated sorted array](array.md#how-to-detect-if-an-element-is-a-pivot-in-a-rotated-sorted-array)
* [How to find a pivot element in a rotated array](array.md#how-to-find-a-pivot-element-in-a-rotated-array)
* [How to find the duplicates in an array](array.md#how-to-find-the-duplicates-in-an-array)
* [How to manage a dynamic array](array.md#how-to-manage-a-dynamic-array)
* [How to test if the array is sorted in ascending or descending order](array.md#how-to-test-if-the-array-is-sorted-in-ascending-or-descending-order)
* [Rotate an array by n elements (n can be negative)](array.md#rotate-an-array-by-n-elements-n-can-be-negative)

### Bit

* [& operator](bit.md)
* [<< operator](bit.md)
* [>> operator](bit.md)
* [>>> operator](bit.md)
* [^ operator](bit.md)
* [Bit vector structure](bit.md#bit-vector-structure)
* [Check exactly one bit is set](bit.md#check-exactly-one-bit-is-set)
* [Clear bits from i to 0](bit.md#clear-bits-from-i-to-0)
* [Clear bits from most significant one to i](bit.md#clear-bits-from-most-significant-one-to-i)
* [Clear ith bit](bit.md#clear-ith-bit)
* [Flip ith bit](bit.md#flip-ith-bit)
* [Get ith bit](bit.md#get-ith-bit)
* [How to flip one bit](bit.md#how-to-flip-one-bit)
* [How to represent signed integers](bit.md#how-to-represent-signed-integers)
* [Set ith bit](bit.md#set-ith-bit)
* [Update a bit from a given value](bit.md#update-a-bit-from-a-given-value)
* [x & 0s](bit.md)
* [x & 1s](bit.md)
* [x & x](bit.md)
* [x ^ 0s](bit.md)
* [x ^ 1s](bit.md)
* [x ^ x](bit.md)
* [x | 0s](bit.md)
* [x | 1s](bit.md)
* [x | x](bit.md)
* [XOR operations](bit.md#xor-operations)
* [| operator](bit.md)
* [~ operator](bit.md)

### Complexity

* [0/1 Knapsack brute force complexity](complexity.md#01-knapsack-brute-force-complexity)
* [0/1 Knapsack memoization complexity](complexity.md#01-knapsack-memoization-complexity)
* [0/1 Knapsack tabulation complexity](complexity.md#01-knapsack-tabulation-complexity)
* [Amortized complexity definition](complexity.md#amortized-complexity-definition)
* [Array complexity: access, search, insert, delete](complexity.md#array-complexity-access-search-insert-delete)
* [B-tree complexity: access, insert, delete](complexity.md#b-tree-complexity-access-insert-delete)
* [BFS and DFS graph traversal time and space complexity](complexity.md#bfs-and-dfs-graph-traversal-time-and-space-complexity)
* [BFS and DFS tree traversal time and space complexity](complexity.md#bfs-and-dfs-tree-traversal-time-and-space-complexity)
* [Big O](complexity.md#big-o)
* [Big Omega](complexity.md#big-omega)
* [Big Theta](complexity.md#big-theta)
* [Binary heap (min-heap or max-heap) complexity: insert, get min (max), delete min (max)](complexity.md#binary-heap-min-heap-or-max-heap-complexity-insert-get-min-max-delete-min-max)
* [BST complexity: access, insert, delete](complexity.md#bst-complexity-access-insert-delete)
* [BST delete algo and complexity](complexity.md#bst-delete-algo-and-complexity)
* [Bubble sort complexity and stability](complexity.md#bubble-sort-complexity-and-stability)
* [Complexity of a function making multiple recursive subcalls](complexity.md#complexity-of-a-function-making-multiple-recursive-subcalls)
* [Complexity to create a trie](complexity.md#complexity-to-create-a-trie)
* [Complexity to insert a key in a trie](complexity.md#complexity-to-insert-a-key-in-a-trie)
* [Complexity to search for a key in a trie](complexity.md#complexity-to-search-for-a-key-in-a-trie)
* [Counting sort complexity, stability, use case](complexity.md#counting-sort-complexity-stability-use-case)
* [Doubly linked list complexity: access, insert, delete](complexity.md#doubly-linked-list-complexity-access-insert-delete)
* [Hash table complexity: search, insert, delete](complexity.md#hash-table-complexity-search-insert-delete)
* [Heapsort complexity, stability, use case](complexity.md#heapsort-complexity-stability-use-case)
* [Insertion sort complexity, stability, use case](complexity.md#insertion-sort-complexity-stability-use-case)
* [Linked list complexity: access, insert, delete](complexity.md#linked-list-complexity-access-insert-delete)
* [Mergesort complexity, stability, use case](complexity.md#mergesort-complexity-stability-use-case)
* [Quicksort complexity, stability, use case](complexity.md#quicksort-complexity-stability-use-case)
* [Radix sort complexity, stability, use case](complexity.md#radix-sort-complexity-stability-use-case)
* [Recursivity impacts on algorithm complexity](complexity.md#recursivity-impacts-on-algorithm-complexity)
* [Red-black tree complexity: access, insert, delete](complexity.md#red-black-tree-complexity-access-insert-delete)
* [Selection sort complexity](complexity.md#selection-sort-complexity)
* [Stack implementations and insert/delete complexity](complexity.md#stack-implementations-and-insertdelete-complexity)
* [Time complexity to build a binary heap](complexity.md#time-complexity-to-build-a-binary-heap)
* [Topological sort complexity](complexity.md#topological-sort-complexity)

### Dynamic Programming

* [Dynamic programming concept](dynamicprogramming.md#dynamic-programming-concept)
* [Memoization vs tabulation](dynamicprogramming.md#memoization-vs-tabulation)

### Encoding

* [ASCII charset](encoding.md#ascii-charset)
* [Difference encoding/charset](encoding.md#difference-encodingcharset)
* [Unicode charset](encoding.md#unicode-charset)

### General

* [Before finding a solution](general.md#before-finding-a-solution)
* [Comparator implementation to order two integers](general.md#comparator-implementation-to-order-two-integers)
* [Different ways for two intervals to relate to each other](general.md#different-ways-for-two-intervals-to-relate-to-each-other)
* [Different ways for two intervals to relate to each other if ordered by start then end](general.md#different-ways-for-two-intervals-to-relate-to-each-other-if-ordered-by-start-then-end)
* [Divide and conquer algorithm paradigm](general.md#divide-and-conquer-algorithm-paradigm)
* [How to name a matrix indexes](general.md#how-to-name-a-matrix-indexes)
* [If stucked on a problem](general.md#if-stucked-on-a-problem)
* [In place definition](general.md#in-place-definition)
* [P vs NP problems](general.md#p-vs-np-problems)
* [Solving optimization problems](general.md#solving-optimization-problems)
* [Stable property](general.md#stable-property)
* [What do to after having designed a solution](general.md#what-do-to-after-having-designed-a-solution)

### Graph
* [A* algorithm](graph.md#a-algorithm)
* [Backedge definition](graph.md#backedge-definition)
* [Best-first search algorithm](graph.md#best-first-search-algorithm)
* [BFS & DFS graph traversal use cases](graph.md#bfs-and-dfs-graph-traversal-time-and-space-complexity)
* [BFS and DFS graph traversal time and space complexity](graph.md#bfs--dfs-graph-traversal-use-cases)
* [Bidirectional search](graph.md#bidirectional-search)
* [Connected graph definition](graph.md#connected-graph-definition)
* [Difference Best-first search and A* algorithms](graph.md#difference-best-first-search-and-a-algorithms)
* [Dijkstra algorithm](graph.md#dijkstra-algorithm)
* [Dynamic connectivity problem](graph.md#dynamic-connectivity-problem)
* [Dynamic connectivity problem - Quick-find solution](graph.md#dynamic-connectivity-problem---quick-find-solution)
* [Dynamic connectivity problem - Quick-union solution](graph.md#dynamic-connectivity-problem---quick-union-solution)
* [Dynamic connectivity problem - Weighted Quick-union solution](graph.md#dynamic-connectivity-problem---weighted-quick-union-solution)
* [Given n tasks from 0 to n-1 and a list of relations so that a -> b means a must be scheduled before b, how to know if it is possible to schedule all the tasks (no cycle)](graph.md#given-n-tasks-from-0-to-n-1-and-a-list-of-relations-so-that-a---b-means-a-must-be-scheduled-before-b-how-to-know-if-it-is-possible-to-schedule-all-the-tasks-no-cycle)
* [Graph definition](graph.md#graph-definition)
* [Graph traversal: BFS](graph.md#graph-traversal-bfs)
* [Graph traversal: DFS](graph.md#graph-traversal-dfs)
* [How to compute the shortest path between two nodes in an unweighted graph](graph.md#how-to-compute-the-shortest-path-between-two-nodes-in-an-unweighted-graph)
* [How to detect a cycle in a directed graph](graph.md#how-to-detect-a-cycle-in-a-directed-graph)
* [How to detect a cycle in an undirected graph](graph.md#how-to-detect-a-cycle-in-an-undirected-graph)
* [How to name a graph with directed edges and without cycle](graph.md#how-to-name-a-graph-with-directed-edges-and-without-cycle)
* [How to name a graph with few edges and with many edges](graph.md#how-to-name-a-graph-with-few-edges-and-with-many-edges)
* [How to name the number of edges](graph.md#how-to-name-the-number-of-edges)
* [How to represent the edges of a graph (structure and complexity)](graph.md#how-to-represent-the-edges-of-a-graph-structure-and-complexity)
* [Topological sort complexity](graph.md#topological-sort-complexity)
* [Topological sort technique](graph.md#topological-sort-technique)
* [Travelling salesman problem](graph.md#travelling-salesman-problem)
* [Two types of graphs](graph.md#two-types-of-graphs)

### Greedy

* [Best-first search algorithm](greedy.md#best-first-search-algorithm)
* [Greedy algorithm](greedy.md#greedy-algorithm)
* [Greedy algorithm: structure](greedy.md#greedy-algorithm-structure)
* [Greedy technique](greedy.md#greedy-technique)
* [Technique - Optimization problems requiring a min or max](greedy.md#technique---optimization-problems-requiring-a-min-or-max)

### Hash Table

* [Hash table complexity: search, insert, delete](hashtable.md#hash-table-complexity-search-insert-delete)
* [Hash table implementation](hashtable.md#hash-table-implementation)

### Heap

* [Binary heap (min-heap or max-heap) complexity: insert, get min (max), delete min (max)](heap.md#binary-heap-min-heap-or-max-heap-complexity-insert-get-min-max-delete-min-max)
* [Binary heap (min-heap or max-heap) data structure used for the implementation](heap.md#binary-heap-min-heap-or-max-heap-data-structure-used-for-the-implementation)
* [Binary heap (min-heap or max-heap) definition](heap.md#binary-heap-min-heap-or-max-heap-definition)
* [Binary heap (min-heap or max-heap) delete min](heap.md#binary-heap-min-heap-or-max-heap-delete-min)
* [Binary heap (min-heap or max-heap) insert algorithm](heap.md#binary-heap-min-heap-or-max-heap-insert-algorithm)
* [Binary heap (min-heap or max-heap) use-cases](heap.md#binary-heap-min-heap-or-max-heap-use-cases)
* [Comparator implementation to order two integers](heap.md#comparator-implementation-to-order-two-integers)
* [Convert an array into a binary heap in place](heap.md#convert-an-array-into-a-binary-heap-in-place)
* [Find the median of a stream of numbers, 2 methods insert(int) and int findMedian()](heap.md#find-the-median-of-a-stream-of-numbers-2-methods-insertint-and-int-findmedian)
* [Given an unsorted array of numbers, find the K largest numbers in it](heap.md#given-an-unsorted-array-of-numbers-find-the-k-largest-numbers-in-it)
* [Heapsort algorithm](heap.md#heapsort-algorithm)
* [Is binary heap stable?](heap.md#is-binary-heap-stable)
* [Time complexity to build a binary heap](heap.md#time-complexity-to-build-a-binary-heap)
* [Two heaps technique](heap.md#two-heaps-technique)
* [Why binary heap over BST for priority queue?](heap.md#why-binary-heap-over-bst-for-priority-queue)

### Linked List

* [Algorithm to reverse a linked list](linkedlist.md#algorithm-to-reverse-a-linked-list)
* [Doubly linked list](linkedlist.md#doubly-linked-list)
* [Doubly linked list complexity: access, insert, delete](linkedlist.md#doubly-linked-list-complexity-access-insert-delete)
* [Get the middle of a linked list](linkedlist.md#get-the-middle-of-a-linked-list)
* [Iterate over two linked lists](linkedlist.md#iterate-over-two-linked-lists)
* [Linked list complexity: access, insert, delete](linkedlist.md#linked-list-complexity-access-insert-delete)
* [Linked list questions prerequisite](linkedlist.md#linked-list-questions-prerequisite)
* [Queue implementations and insert/delete complexity](linkedlist.md#queue-implementations-and-insertdelete-complexity)
* [Ring buffer (or circular buffer) structure](linkedlist.md#ring-buffer-or-circular-buffer-structure)
* [What if we need to iterate backwards on a singly linked list in constant space without mutating the input?](linkedlist.md#what-if-we-need-to-iterate-backwards-on-a-singly-linked-list-in-constant-space-without-mutating-the-input)

### Math

* [a = a property](math.md#a--a-property)
* [If a = b and b = c then a = c property](math.md#if-a--b-and-b--c-then-a--c-property)
* [If a = b then b = a property](math.md#if-a--b-then-b--a-property)
* [Logarithm definition](math.md#logarithm-definition)
* [Median of a sorted array](math.md#median-of-a-sorted-array)
* [n-choose-k problems](math.md#n-choose-k-problems)
* [Probability: P(a ∩ b) // inter](math.md#probability-pa--b--inter)
* [Probability: P(a ∪ b) // union](math.md#probability-pa--b--union)
* [Probability: Pb(a) // probability of a knowing b](math.md#probability-pba--probability-of-a-knowing-b)

### Queue

* [Dequeue data structure](queue.md#dequeue-data-structure)
* [Queue](queue.md#queue)
* [Queue implementations and insert/delete complexity](queue.md#queue-implementations-and-insertdelete-complexity)

### Recursion

* [How to handle a recursive function that need to return a list](recursion.md#how-to-handle-a-recursive-function-that-need-to-return-a-list)
* [How to handle a recursive function that need to return a maximum value](recursion.md#how-to-handle-a-recursive-function-that-need-to-return-a-maximum-value)
* [Loop inside of a recursive function?](recursion.md#loop-inside-of-a-recursive-function)

### Sort

* [Bubble sort algorithm](sort.md#bubble-sort-algorithm)
* [Bubble sort complexity and stability](sort.md#bubble-sort-complexity-and-stability)
* [Counting sort complexity, stability, use case](sort.md#counting-sort-complexity-stability-use-case)
* [Counting sort algorithm](sort.md#counting-sort-algorithm)
* [Heapsort algorithm](sort.md#heapsort-algorithm)
* [Heapsort complexity, stability, use case](sort.md#heapsort-complexity-stability-use-case)
* [Insertion sort algorithm](sort.md#insertion-sort-algorithm)
* [Insertion sort complexity, stability, use case](sort.md#insertion-sort-complexity-stability-use-case)
* [Mergesort algorithm](sort.md#mergesort-algorithm)
* [Mergesort complexity, stability, use case](sort.md#mergesort-complexity-stability-use-case)
* [Quicksort algorithm](sort.md#quicksort-algorithm)
* [Quicksort complexity, stability, use case](sort.md#quicksort-complexity-stability-use-case)
* [Radix sort algorithm](sort.md#radix-sort-algorithm)
* [Radix sort complexity, stability, use case](sort.md#radix-sort-complexity-stability-use-case)
* [Selection sort algorithm](sort.md#selection-sort-algorithm)
* [Selection sort complexity](sort.md#selection-sort-complexity)
* [Shuffling an array](sort.md#shuffling-an-array)

### Stack

* [Stack](stack.md#stack)
* [Stack implementations and insert/delete complexity](stack.md#stack-implementations-and-insertdelete-complexity)

### String

* [First check to test if two strings are a permutation or a rotation of each other](string.md#first-check-to-test-if-two-strings-are-a-permutation-or-a-rotation-of-each-other)
* [How to print all the possible permutations of a string](string.md#how-to-print-all-the-possible-permutations-of-a-string)
* [Rabin-Karp substring search](string.md#rabin-karp-substring-search)
* [String permutation vs rotation](string.md#string-permutation-vs-rotation)
* [String questions prerequisite](string.md#string-questions-prerequisite)

### Technique

* [0/1 Knapsack brute force technique](technique.md#01-knapsack-brute-force-technique)
* [0/1 Knapsack memoization technique](technique.md#01-knapsack-memoization-technique)
* [0/1 Knapsack tabulation technique](technique.md#01-knapsack-tabulation-technique)
* [Backtracking technique](technique.md#backtracking-technique)
* [Cyclic sort technique](technique.md#cyclic-sort-technique)
* [Greedy technique](technique.md#greedy-technique)
* [K-way merge technique](technique.md#k-way-merge-technique)
* [Runner technique](technique.md#runner-technique)
* [Simplification technique](technique.md#simplification-technique)
* [Sliding window technique](technique.md#sliding-window-technique)
* [Subsets technique](technique.md#subsets-technique)
* [Technique - Dealing with cycles in a linked list or an array](technique.md#technique---dealing-with-cycles-in-a-linked-list-or-an-array)
* [Technique - Find all the permutations or combinations](technique.md#technique---find-all-the-permutations-or-combinations)
* [Technique - Find an element in a sorted array or linked list](technique.md#technique---find-an-element-in-a-sorted-array-or-linked-list)
* [Technique - Find or calculate something among all the contiguous subarrays of a given size](technique.md#technique---find-or-calculate-something-among-all-the-contiguous-subarrays-of-a-given-size)
* [Technique - Find the longest/shortest substring or subarray](technique.md#technique---find-the-longestshortest-substring-or-subarray)
* [Technique - Find the smallest/largest/median element of a set](technique.md#technique---find-the-smallestlargestmedian-element-of-a-set)
* [Technique - Finding a certain element in a linked list (e.g. middle)](technique.md#technique---finding-a-certain-element-in-a-linked-list-eg-middle)
* [Technique - Given a sorted array, find a set of elements that fullfill certain conditions](technique.md#technique---given-a-sorted-array-find-a-set-of-elements-that-fullfill-certain-conditions)
* [Technique - Given an array of size n containing integer from 1 to n (e.g. with one duplicate)](technique.md#technique---given-an-array-of-size-n-containing-integer-from-1-to-n-eg-with-one-duplicate)
* [Technique - Given time intervals](technique.md#technique---given-time-intervals)
* [Technique - How to get the K biggest/smallest/frequent elements](technique.md#technique---how-to-get-the-k-biggestsmallestfrequent-elements)
* [Technique - Optimization problems requiring a min or max](technique.md#technique---optimization-problems-requiring-a-min-or-max)
* [Technique - Problems featuring a list of sorted arrays (merge or find the smallest element)](technique.md#technique---problems-featuring-a-list-of-sorted-arrays-merge-or-find-the-smallest-element)
* [Technique - Scheduling problem with n tasks where each task can have constraints to be completed before others](technique.md#technique---scheduling-problem-with-n-tasks-where-each-task-can-have-constraints-to-be-completed-before-others)
* [Technique - Situations like priority queue or scheduling](technique.md#technique---situations-like-priority-queue-or-scheduling)
* [Top K elements technique (biggest and smallest)](technique.md#top-k-elements-technique-biggest-and-smallest)
* [Topological sort technique](technique.md#topological-sort-technique)
* [Traversal technique](technique.md#traversal-technique)
* [Two heaps technique](technique.md#two-heaps-technique)
* [Two pointers technique](technique.md#two-pointers-technique)
* [What if we need to iterate backwards on a singly linked list in constant space without mutating the input?](technique.md#what-if-we-need-to-iterate-backwards-on-a-singly-linked-list-in-constant-space-without-mutating-the-input)

### Tree

* [2-3 tree](tree.md#2-3-tree)
* [AVL tree](tree.md#avl-tree)
* [B-tree complexity: access, insert, delete](tree.md#b-tree-complexity-access-insert-delete)
* [B-tree: definition and use case](tree.md#b-tree-definition-and-use-case)
* [Balanced binary tree definition](tree.md#balanced-binary-tree-definition)
* [Balanced BST use case: B-tree, Red-black tree, AVL tree](tree.md#balanced-bst-use-case-b-tree-red-black-tree-avl-tree)
* [BFS and DFS tree traversal time and space complexity](tree.md#bfs-and-dfs-tree-traversal-time-and-space-complexity)
* [Binary tree BFS traversal](tree.md#binary-tree-bfs-traversal)
* [Binary tree definition](tree.md#binary-tree-definition)
* [Binary tree DFS traversal: in-order, pre-order and post-order](tree.md#binary-tree-dfs-traversal-in-order-pre-order-and-post-order)
* [Binary tree: complete](tree.md#binary-tree-complete)
* [Binary tree: full](tree.md#binary-tree-full)
* [Binary tree: perfect](tree.md#binary-tree-perfect)
* [BST complexity: access, insert, delete](tree.md#bst-complexity-access-insert-delete)
* [BST definition](tree.md#bst-definition)
* [BST delete algo and complexity](tree.md#bst-delete-algo-and-complexity)
* [BST insert algo](tree.md#bst-insert-algo)
* [BST questions prerequisite](tree.md#bst-questions-prerequisite)
* [Complexity to create a trie](tree.md#complexity-to-create-a-trie)
* [Complexity to insert a key in a trie](tree.md#complexity-to-insert-a-key-in-a-trie)
* [Complexity to search for a key in a trie](tree.md#complexity-to-search-for-a-key-in-a-trie)
* [Given a binary tree, algorithm to populate an array to represent its level-by-level traversal](tree.md#given-a-binary-tree-algorithm-to-populate-an-array-to-represent-its-level-by-level-traversal)
* [How to calculate the path number of a node while traversing using DFS?](tree.md#how-to-calculate-the-path-number-of-a-node-while-traversing-using-dfs)
* [Min (or max) value in a BST](tree.md#min-or-max-value-in-a-bst)
* [Red-Black tree](tree.md#red-black-tree)
* [Red-black tree complexity: access, insert, delete](tree.md#red-black-tree-complexity-access-insert-delete)
* [Reverse a binary tree algo](tree.md#reverse-a-binary-tree-algo)
* [Trie definition, implementation and use case](tree.md#trie-definition-implementation-and-use-case)
* [Why to use BST over hash table](tree.md#why-to-use-bst-over-hash-table)


                                 Apache License
                           Version 2.0, January 2004
                        https://www.apache.org/licenses/

   TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION

   1. Definitions.

      "License" shall mean the terms and conditions for use, reproduction,
      and distribution as defined by Sections 1 through 9 of this document.

      "Licensor" shall mean the copyright owner or entity authorized by
      the copyright owner that is granting the License.

      "Legal Entity" shall mean the union of the acting entity and all
      other entities that control, are controlled by, or are under common
      control with that entity. For the purposes of this definition,
      "control" means (i) the power, direct or indirect, to cause the
      direction or management of such entity, whether by contract or
      otherwise, or (ii) ownership of fifty percent (50%) or more of the
      outstanding shares, or (iii) beneficial ownership of such entity.

      "You" (or "Your") shall mean an individual or Legal Entity
      exercising permissions granted by this License.

      "Source" form shall mean the preferred form for making modifications,
      including but not limited to software source code, documentation
      source, and configuration files.

      "Object" form shall mean any form resulting from mechanical
      transformation or translation of a Source form, including but
      not limited to compiled object code, generated documentation,
      and conversions to other media types.

      "Work" shall mean the work of authorship, whether in Source or
      Object form, made available under the License, as indicated by a
      copyright notice that is included in or attached to the work
      (an example is provided in the Appendix below).

      "Derivative Works" shall mean any work, whether in Source or Object
      form, that is based on (or derived from) the Work and for which the
      editorial revisions, annotations, elaborations, or other modifications
      represent, as a whole, an original work of authorship. For the purposes
      of this License, Derivative Works shall not include works that remain
      separable from, or merely link (or bind by name) to the interfaces of,
      the Work and Derivative Works thereof.

      "Contribution" shall mean any work of authorship, including
      the original version of the Work and any modifications or additions
      to that Work or Derivative Works thereof, that is intentionally
      submitted to Licensor for inclusion in the Work by the copyright owner
      or by an individual or Legal Entity authorized to submit on behalf of
      the copyright owner. For the purposes of this definition, "submitted"
      means any form of electronic, verbal, or written communication sent
      to the Licensor or its representatives, including but not limited to
      communication on electronic mailing lists, source code control systems,
      and issue tracking systems that are managed by, or on behalf of, the
      Licensor for the purpose of discussing and improving the Work, but
      excluding communication that is conspicuously marked or otherwise
      designated in writing by the copyright owner as "Not a Contribution."

      "Contributor" shall mean Licensor and any individual or Legal Entity
      on behalf of whom a Contribution has been received by Licensor and
      subsequently incorporated within the Work.

   2. Grant of Copyright License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      copyright license to reproduce, prepare Derivative Works of,
      publicly display, publicly perform, sublicense, and distribute the
      Work and such Derivative Works in Source or Object form.

   3. Grant of Patent License. Subject to the terms and conditions of
      this License, each Contributor hereby grants to You a perpetual,
      worldwide, non-exclusive, no-charge, royalty-free, irrevocable
      (except as stated in this section) patent license to make, have made,
      use, offer to sell, sell, import, and otherwise transfer the Work,
      where such license applies only to those patent claims licensable
      by such Contributor that are necessarily infringed by their
      Contribution(s) alone or by combination of their Contribution(s)
      with the Work to which such Contribution(s) was submitted. If You
      institute patent litigation against any entity (including a
      cross-claim or counterclaim in a lawsuit) alleging that the Work
      or a Contribution incorporated within the Work constitutes direct
      or contributory patent infringement, then any patent licenses
      granted to You under this License for that Work shall terminate
      as of the date such litigation is filed.

   4. Redistribution. You may reproduce and distribute copies of the
      Work or Derivative Works thereof in any medium, with or without
      modifications, and in Source or Object form, provided that You
      meet the following conditions:

      (a) You must give any other recipients of the Work or
          Derivative Works a copy of this License; and

      (b) You must cause any modified files to carry prominent notices
          stating that You changed the files; and

      (c) You must retain, in the Source form of any Derivative Works
          that You distribute, all copyright, patent, trademark, and
          attribution notices from the Source form of the Work,
          excluding those notices that do not pertain to any part of
          the Derivative Works; and

      (d) If the Work includes a "NOTICE" text file as part of its
          distribution, then any Derivative Works that You distribute must
          include a readable copy of the attribution notices contained
          within such NOTICE file, excluding those notices that do not
          pertain to any part of the Derivative Works, in at least one
          of the following places: within a NOTICE text file distributed
          as part of the Derivative Works; within the Source form or
          documentation, if provided along with the Derivative Works; or,
          within a display generated by the Derivative Works, if and
          wherever such third-party notices normally appear. The contents
          of the NOTICE file are for informational purposes only and
          do not modify the License. You may add Your own attribution
          notices within Derivative Works that You distribute, alongside
          or as an addendum to the NOTICE text from the Work, provided
          that such additional attribution notices cannot be construed
          as modifying the License.

      You may add Your own copyright statement to Your modifications and
      may provide additional or different license terms and conditions
      for use, reproduction, or distribution of Your modifications, or
      for any such Derivative Works as a whole, provided Your use,
      reproduction, and distribution of the Work otherwise complies with
      the conditions stated in this License.

   5. Submission of Contributions. Unless You explicitly state otherwise,
      any Contribution intentionally submitted for inclusion in the Work
      by You to the Licensor shall be under the terms and conditions of
      this License, without any additional terms or conditions.
      Notwithstanding the above, nothing herein shall supersede or modify
      the terms of any separate license agreement you may have executed
      with Licensor regarding such Contributions.

   6. Trademarks. This License does not grant permission to use the trade
      names, trademarks, service marks, or product names of the Licensor,
      except as required for reasonable and customary use in describing the
      origin of the Work and reproducing the content of the NOTICE file.

   7. Disclaimer of Warranty. Unless required by applicable law or
      agreed to in writing, Licensor provides the Work (and each
      Contributor provides its Contributions) on an "AS IS" BASIS,
      WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
      implied, including, without limitation, any warranties or conditions
      of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A
      PARTICULAR PURPOSE. You are solely responsible for determining the
      appropriateness of using or redistributing the Work and assume any
      risks associated with Your exercise of permissions under this License.

   8. Limitation of Liability. In no event and under no legal theory,
      whether in tort (including negligence), contract, or otherwise,
      unless required by applicable law (such as deliberate and grossly
      negligent acts) or agreed to in writing, shall any Contributor be
      liable to You for damages, including any direct, indirect, special,
      incidental, or consequential damages of any character arising as a
      result of this License or out of the use or inability to use the
      Work (including but not limited to damages for loss of goodwill,
      work stoppage, computer failure or malfunction, or any and all
      other commercial damages or losses), even if such Contributor
      has been advised of the possibility of such damages.

   9. Accepting Warranty or Additional Liability. While redistributing
      the Work or Derivative Works thereof, You may choose to offer,
      and charge a fee for, acceptance of support, warranty, indemnity,
      or other liability obligations and/or rights consistent with this
      License. However, in accepting such obligations, You may act only
      on Your own behalf and on Your sole responsibility, not on behalf
      of any other Contributor, and only if You agree to indemnify,
      defend, and hold each Contributor harmless for any liability
      incurred by, or claims asserted against, such Contributor by reason
      of your accepting any such warranty or additional liability.

   END OF TERMS AND CONDITIONS

   APPENDIX: How to apply the Apache License to your work.

      To apply the Apache License to your work, attach the following
      boilerplate notice, with the fields enclosed by brackets "[]"
      replaced with your own identifying information. (Don't include
      the brackets!)  The text should be enclosed in the appropriate
      comment syntax for the file format. We also recommend that a
      file or class name and description of purpose be included on the
      same "printed page" as the copyright notice for easier
      identification within third-party archives.

   Copyright 2020 Rolando Gopez Lacuata.

   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

       https://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
